//temporary backup of what I had in the core.frag, started from scratch to debug it



#version 400 core

in vec2 TexCoord;
in vec4 frag_pos;
in vec3 normal;

out vec4 color;

uniform sampler2D mapKd;
uniform sampler2D mapKs;

uniform int lightNum;
uniform mat3 lightPos;

uniform float la;
uniform float ld;
uniform float ls;

uniform vec3 ka;
uniform vec3 kd;
uniform vec3 ks;

uniform float ns;


float fatt (vec3 VL){
	float d = length(VL);
	return 1 / (d * d);
}

//já tem
float pow (float toMultiply, int multiplier){	
	float result = 0;
	for (int i = 0; i < multiplier; i++){
		result *= toMultiply;
	} 
	return result;
}

float ambient(){
	return la * ka;
}

float diffuse(int numOfLigths){
	float d = 0;

	for (int i = 0; i < numOfLigths; i++){
		
	vec4 V4 = lightPos[i] - frag_pos;
	vec3 V = vec3(V4.x, V4.y, V4.z);
		
		float Ad = max(0, dot(normal, V));
		d += fatt(V) * ld * kd * Ad * texture(mapKd, TexCoord); 
	}
	
	if(d < 0){
		d= 0;
	}

	return d;
}

float specular(int numOfLigths){
	float s = 0;

	//for (int i = 0; i < numOfLigths; i++){

		vec4 V4 = lightPos[i] - frag_pos;
		vec3 V = vec3(V4.x, V4.y, V4.z);

		vec3 R = reflect(normal, lightPos[i]);
		float As = dot (V, R);
		float s = pow (As, ns);
		
		s += fatt(V) * ls * ks * s * mapKs;
	}

	if(s < 0){
		s= 0;
	}

	
	return s;
}


void main() {
	vec4 tex1 = texture( texture1, TexCoord ); //mapkd

	//for (int i = 0; i < numOfLigths; i++){
	//sai com especular e difusa de cada parte

	//aí, depois, soma com a ambiente
	float I = ambient() * mapKd + diffuse(lightNum) + specular(lightNum);
	color = I * tex1;
	
	//aplicar fog depos do calc do fog percentual do fog peso pela distancia do fragmento pelo da camera observador
	//tipo fatt, mas troca os pontos e distância sobre 1
	//depois de calcular percentual, chamar função mix () passa rgb e rgb e VALOR DO MIX, função da opengl peso do segindo árâmetro colr da iluna~çaõ e do fog e resultado da atuanação, 1/distância
	
	//color = tex1;
}
